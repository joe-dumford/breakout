{"version":3,"sources":["utils.js","game/levels.js","game/vector.js","game/core.js","components/level.js","components/lives.js","components/block.js","components/paddle.js","components/ball.js","components/scene.js","App.js","components/page.js","serviceWorker.js","index.js"],"names":["getRange","length","Array","keys","getRandomFrom","args","Math","floor","random","registerListener","eventName","handler","window","addEventListener","removeEventListener","getRandomBlock","getBlocks","rows","columns","map","LEVELS","lives","paddleWidth","speed","blocks","Vector","x","y","this","number","hypot","scaleBy","other","amt","dotProduct","normal","subtract","projectOn","degrees","radians","PI","toRadians","cos","sin","atan2","crossProduct","MOVEMENT","DOWN","LEFT","RIGHT","UP","LEFT_UP","add","normalize","RIGHT_UP","getInitialPaddleAndBall","width","height","paddleY","paddle","position","ball","center","BALL_RADIUS","radius","direction","getGameStateFromLevel","arrays","blocksStart","rowsOfBlocks","row","i","density","j","size","reduce","acc","isInBoundaries","oneSide","otherSide","oneBoundary","otherBoundary","getNewGameState","state","movement","timespan","distance","withNewX","getNewPaddle","oldDirection","newBallCenter","ballBottom","withNewBallProps","props","withNewBallDirection","vector","minAngle","angle","angleBetween","maxAngle","rotate","getAdjustedVector","distortionLevel","getComponent","distortion","getDistortedDirection","reflect","ballLeft","ballRight","ballTop","paddleLeft","paddleRight","paddleTop","abs","array","element","block","find","newBlock","filter","e","oldElement","newElement","updateElement","blockTop","blockBottom","blockLeft","getNewBallNormal","level","unit","fontSize","className","containerWidth","rx","key","colors","fill","cx","cy","r","MOVEMENT_KEYS","getProjectors","containerSize","gameSize","widthRatio","heightRatio","unitOnScreen","min","projectDistance","projectVector","getInitialState","inState","localStorage","getItem","parseInt","getInitialLevel","game","time","Date","now","stopTime","undefined","ACTION","HANDLER","includes","newState","newGame","setItem","reducer","type","payload","useReducer","dispatch","actionDispatch","useEffect","timerId","setInterval","unregisterKeydown","which","unregisterKeyup","clearInterval","viewWidth","Page","sceneContainer","useRef","useState","setSize","onResize","current","getBoundingClientRect","unregisterResizeListener","ref","Boolean","location","hostname","match","ReactDOM","render","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.366997c4.chunk.js","sourcesContent":["export const getRange = length => [...Array(length).keys()]\n\nexport const getRandomFrom = (...args) => args[Math.floor(Math.random() * args.length)]\n\nexport const flatten = arrays => arrays.reduce((acc, row) => [...acc, ...row], [])\n\nexport const registerListener = (eventName, handler) => {\n    window.addEventListener(eventName, handler)\n    return () => window.removeEventListener(eventName, handler)\n}\n\n//Concerting Degrees to Radians\nexport const toDegrees = radians => (radians * 180) / Math.PI\nexport const toRadians = degrees => (degrees * Math.PI) / 180\n\nexport const withoutElement = (array, element) => array.filter(e => e !== element)\nexport const updateElement = (array, oldElement, newElement) => array.map(e => e === oldElement ? newElement : e)\n","import { getRange } from '../utils'\n\nexport const BLOCK_MAX_DENSITY = 3\n\nconst getRandomBlock = () => Math.floor(Math.random() * BLOCK_MAX_DENSITY)\n\nconst getBlocks = (rows, columns) => \n    getRange(rows).map(() => getRange(columns).map(getRandomBlock))\n\nexport const LEVELS = [\n    {\n        lives: 5,\n        paddleWidth: 3.5,\n        speed: 1,\n        blocks: getBlocks(3, 6)\n    },\n    {\n        lives: 4,\n        paddleWidth: 3,\n        speed: 1.4,\n        blocks: getBlocks(4, 7)\n      },\n      {\n        lives: 3,\n        paddleWidth: 2.5,\n        speed: 1.8,\n        blocks: getBlocks(5, 8)\n      },\n      {\n        lives: 3,\n        paddleWidth: 2,\n        speed: 2.2,\n        blocks: getBlocks(6, 9)\n      },\n]","import { toDegrees, toRadians } from '../utils'\n\nexport default class Vector {\n    constructor(x, y) {\n        this.x = x\n        this.y = y\n    }\n\n     scaleBy(number) {\n    return new Vector(this.x * number, this.y * number);\n  }\n    //Math.hypot to calculate the Hypotenuse of the right triangle. Using this gives the two corners, or length of the gameboard.\n   length() {\n    return Math.hypot(this.x, this.y)\n  }\n\n      add({ x, y }) {\n    return new Vector(this.x + x, this.y + y)\n  }\n\n    normalize() {\n    return this.scaleBy(1 / this.length())\n  }\n\n\n    subtract({ x, y }) {\n        return new Vector (this.x - x, this.y - y)\n    }\n\n    dotProduct({ x, y }) {\n        return this.x * x + this.y * y\n    }\n\n    projectOn(other) {\n        const amt = this.dotProduct(other) / other.length()\n        return new Vector(amt * other.x, amt * other.y)\n    }\n\n    reflect(normal) {\n        return this.subtract(this.projectOn(normal).scaleBy(2))\n    }\n\n    rotate(degrees) {\n        const radians = toRadians(degrees)\n        const cos = Math.cos(radians)\n        const sin = Math.sin(radians)\n\n        return new Vector(\n            this.x * cos - this.y * sin,\n            this.x * sin + this.y * cos\n        )\n    }\n\n    crossProduct({ x, y }) {\n        return this.x * y - x * this.y\n    }\n\n    angleBetween(other) {\n        return toDegrees(\n            Math.atan2(this.crossProduct(other), this.dotProduct(other))\n        )\n    }\n}","import Vector from './vector'\nimport { flatten, getRandomFrom, withoutElement, updateElement } from '../utils'\n\nconst PADDLE_AREA = 1 / 3\nconst BLOCK_HEIGHT = 1 / 3\nconst PADDLE_HEIGHT = BLOCK_HEIGHT\nconst BALL_RADIUS = 1 / 5\nconst DISTANCE_IN_MS = 0.005\n\nexport const MOVEMENT = {\n    LEFT: 'LEFT',\n    RIGHT: 'RIGHT'\n}\n\nconst DOWN = new Vector(0, 1)\nconst LEFT = new Vector(-1, 0)\nconst RIGHT = new Vector(1, 0)\nconst UP = new Vector(0, -1)\n\nconst LEFT_UP = LEFT.add(UP).normalize()\nconst RIGHT_UP = RIGHT.add(UP).normalize()\n\n//Setting the initial position for Paddle and Ball\nexport const getInitialPaddleAndBall = (width, height, paddleWidth) => {\n    const paddleY = height - PADDLE_HEIGHT\n    const paddle = {\n        position: new Vector((width - paddleWidth) / 2, paddleY),\n        width: paddleWidth,\n        height: PADDLE_HEIGHT\n    }\n    const ball = {\n        center: new Vector(height / 2, paddleY - BALL_RADIUS * 2),\n        radius: BALL_RADIUS,\n        direction: getRandomFrom(LEFT_UP, RIGHT_UP)\n    }\n    return {\n        paddle,\n        ball\n    }\n}\n\n//Establishing the state of the game. Hard or easy, number of lives, strength of blocks etc.\nexport const getGameStateFromLevel = ({\n    lives,\n    paddleWidth,\n    speed,\n    blocks\n}) => {\n    const width = blocks[0].length\n    const height = width\n\n    const blocksStart = ((height - height * PADDLE_AREA) - blocks.length * BLOCK_HEIGHT) / 2\n\n    const rowsOfBlocks = blocks.map((row, i) =>\n        row.map((density, j) => ({\n            density,\n            position: new Vector(j, blocksStart + (i * BLOCK_HEIGHT)),\n            width: 1,\n            height: BLOCK_HEIGHT\n        })))\n\n    const size = {\n        width,\n        height\n    }\n    return {\n        size,\n        blocks: flatten(rowsOfBlocks),\n        ...getInitialPaddleAndBall(width, height, paddleWidth),\n        lives,\n        speed\n    }\n}\n\n//Altering the direction of the ball after contact with brick or paddle. Distorted direction adds a small random vector to make the gameplay more fun.\nconst getDistortedDirection = (vector, distortionLevel = 0.3) => {\n    const getComponent = () => Math.random() * distortionLevel - distortionLevel / 2\n    const distortion = new Vector(getComponent(), getComponent())\n    return vector.add(distortion).normalize()\n  }\n  \n//Every update checks if player wanted to move paddle, if so, it will calculate new position. Otherwise it will return new vector\nconst getNewPaddle = (paddle, size, distance, movement) => {\n    paddle.width = 7;\n    if (!movement) return paddle\n    const direction = movement === MOVEMENT.LEFT ? LEFT : RIGHT\n\n    const { x } = paddle.position.add(direction.scaleBy(distance))\n    const withNewX = x => ({\n        ...paddle,\n        position: new Vector(x, paddle.position.y)\n    })\n    if (x + paddle.width > size.width) {\n        return withNewX(size.width - paddle.width)\n    } else if (x + paddle.width < size.width) {\n      return withNewX(size.width + paddle.width)\n    }\n    return withNewX(x)\n}\n\n//Function to check if at least one side of the object is inside the boundaries. i.e. is the ball within the size of the block or not\nconst isInBoundaries = (oneSide, otherSide, oneBoundary, otherBoundary) => (\n    (oneSide >= oneBoundary && oneSide <= otherBoundary) ||\n    (otherSide >= oneBoundary && otherSide <= otherBoundary)\n  )\n\n//Function to avoid the ball from bouncing back and forth between walls. This will happen when the angle normal of the wall and the direction is close to 0 or 90 degrees or -90 degrees. \nconst getAdjustedVector = (normal, vector, minAngle = 15) => {\n    const angle = normal.angleBetween(vector)\n    const maxAngle = 90 - minAngle\n    if (angle < 0) {\n        if (angle > -minAngle) {\n            return normal.rotate(-minAngle)\n        }\n        if (angle < -maxAngle) {\n            return normal.rotate(-maxAngle)\n        }\n    } else {\n        if (angle < minAngle) {\n            return normal.rotate(minAngle)\n        }\n        if (angle > maxAngle) {\n            return normal.rotate(maxAngle)\n        }\n    }\n    return vector\n}\n\n//Function that creates a new state based on the old state, movement of the paddle and timespan between last update and now.\nexport const getNewGameState = (state, movement, timespan) => {\n    const { size, speed, lives } = state\n    const distance = timespan * DISTANCE_IN_MS * speed\n    const paddle = getNewPaddle(state.paddle, size, distance, movement)\n  \n    const { radius } = state.ball\n    const oldDirection = state.ball.direction\n    const newBallCenter = state.ball.center.add(oldDirection.scaleBy(distance))\n    const ballBottom = newBallCenter.y + radius\n    if (ballBottom > size.height) {\n      return {\n        ...state,\n        ...getInitialPaddleAndBall(size.width, size.height, paddle.width),\n        lives: lives - 1\n      }\n    }\n\n    const withNewBallProps = props => ({\n      ...state,\n      paddle,\n      ball: {\n        ...state.ball,\n        ...props\n      }\n    })\n  \n    const withNewBallDirection = normal => {\n      const distorted = getDistortedDirection(oldDirection.reflect(normal))\n      const direction = getAdjustedVector(normal, distorted)\n      return withNewBallProps({ direction })\n    }\n    const ballLeft = newBallCenter.x - radius\n    const ballRight = newBallCenter.x + radius\n    const ballTop = newBallCenter.y - radius\n    const paddleLeft = paddle.position.x\n    const paddleRight = paddleLeft+ paddle.width\n    const paddleTop = paddle.position.y\n  \n    //Checking if the ball hits the paddle or one of the walls. If so, passing the direction of normal to withNewBallDirection to return a new state with updated ball and paddle.\n    const ballGoingDown = Math.abs(UP.angleBetween(oldDirection)) > 90\n    const hitPaddle = ballGoingDown && ballBottom >= paddleTop && ballRight >= paddleLeft && ballLeft <= paddleRight\n    if (hitPaddle) return withNewBallDirection(UP)\n    if (ballTop <= 0) return withNewBallDirection(DOWN)\n    if (ballLeft <= 0) return withNewBallDirection(RIGHT)\n    if (ballRight >= size.width) return withNewBallDirection(LEFT)\n  \n    const block = state.blocks.find(({ position, width, height }) => (\n      isInBoundaries(ballTop, ballBottom, position.y, position.y + height) &&\n      isInBoundaries(ballLeft, ballRight, position.x, position.x + width) \n    ))\n    //If the ball hits one of the blocks, return the updated blocks and ball with the direction it bounced from off the block sides.\n    \n  if (block) {\n    const density = block.density - 1\n    const newBlock = { ...block, density }\n    const blocks = density < 0 ? withoutElement(state.blocks, block) : updateElement(state.blocks, block, newBlock)\n      \n      const getNewBallNormal = () => {\n        const blockTop = block.position.y\n        const blockBottom = blockTop + block.height\n        const blockLeft = block.position.x\n        if (ballTop > blockTop - radius && ballBottom < blockBottom + radius) {\n          if (ballLeft < blockLeft) return LEFT\n          if (ballRight > blockLeft + block.width) return RIGHT\n        }\n        if (ballTop > blockTop) return DOWN\n        if (ballTop <= blockTop) return UP\n      }\n      return {\n        ...withNewBallDirection(getNewBallNormal()),\n        blocks\n      }\n    }\n    return withNewBallProps({ center: newBallCenter })\n  }\n","import React from 'react'\n\nexport default ({ level, unit }) => {\n  return (\n    <text x={unit} y={unit * 2} fontSize={unit} className='level'>LEVEL: {level} </text>\n  )\n}","import React from 'react'\n\nimport { getRange } from '../utils'\n\nexport default ({ lives, containerWidth, unit }) => {\n  const width = unit * 2\n  return getRange(lives).map(i => (\n    <rect\n      className='life'\n      rx={unit / 4}\n      height={unit}\n      width={width}\n      y={unit}\n      x={containerWidth - unit - width * (i + 1) - (unit / 2) * i}\n      key={i}\n    />\n  ))\n}","import React from 'react'\nimport { getRange } from '../utils';\nimport { BLOCK_MAX_DENSITY } from '../game/levels';\n\n//Changing Opacity of blocks depending on how many times they've been hit\nconst colors = getRange(BLOCK_MAX_DENSITY).map(i => `rgba(26, 188, 156, ${1 / (BLOCK_MAX_DENSITY - i)})`)\n\nexport default ({ x, y, width, height, density }) => (\n  <rect className='block' fill={colors[density]} x={x} y={y} width={width} height={height} />\n)","import React from 'react'\n\nexport default ({ x, y, width, height }) => (\n  <rect className='paddle' x={x} y={y} width={width} height={height} />\n)","import React from 'react'\n\nexport default ({ x, y, radius }) => (\n  <circle className='ball' cx={x} cy={y} r={radius} />\n)\n","  import React, { useEffect, useReducer } from 'react'\n\nimport { LEVELS } from '../game/levels'\nimport { MOVEMENT, getNewGameState, getGameStateFromLevel } from '../game/core'\nimport { registerListener } from '../utils'\n\nimport Level from './level'\nimport Lives from './lives'\nimport Block from './block'\nimport Paddle from './paddle'\nimport Ball from './ball'\n\n//Object that tracks movement to key codes on keyboard.\nconst MOVEMENT_KEYS = {\n    LEFT: [65, 37],\n    RIGHT: [68, 39]\n}\n\n//If player presses space bar the game is paused or resumed.\nconst STOP_KEY = 32\n\n//Updating the state of the game and rerender 60 times per second.\nconst UPDATE_EVERY = 1000 / 60\n\n//Saving players progress to local storage\nconst getInitialLevel = () => {\n    const inState = localStorage.getItem('level')\n    return inState ? parseInt(inState, 10) : 0\n}\n\nconst getProjectors = (containerSize, gameSize) => {\n    const widthRatio = containerSize.width / gameSize.width\n    const heightRatio = containerSize.height / gameSize.height\n    const unitOnScreen = Math.min(widthRatio, heightRatio)\n\n    return {\n        projectDistance: distance => distance * unitOnScreen,\n        projectVector: vector => vector.scaleBy(unitOnScreen)\n    }\n}\n\nconst getInitialState = containerSize => {\n    const level = getInitialLevel()\n    const game = getGameStateFromLevel(LEVELS[level])\n    const {\n        projectDistance,\n        projectVector\n    } = getProjectors(containerSize, game.size)\n    return {\n        level,\n        game,\n        containerSize,\n        projectDistance,\n        projectVector,\n        time: Date.now(),\n        stopTime: undefined,\n        movement: undefined\n    }\n}\n\n//Handling situations when container size changes(in order to render game properly) Also, when player presses or releases keys on keyboard; every few milliseconds will be called tick action and reducer will return a new state of the game.\nconst ACTION = {\n    CONTAINER_SIZE_CHANGE: 'CONTAINER_SIZE_CHANGE',\n    KEY_DOWN: 'KEY_DOWN',\n    KEY_UP: 'KEY_UP',\n    TICK: 'TICK'\n}\n\n//Handler function for each action receives old state and payload.\nconst HANDLER = {\n    //When container size changes, update the state with new projectors.\n    [ACTION.CONTAINER_SIZE_CHANGE]: (state, containerSize) => ({\n        ...state,\n        containerSize,\n        ...getProjectors(containerSize, state.game.size)\n    }),\n    //When player presses keys down, checking if it is a right or left move.\n    [ACTION.KEY_DOWN]: (state, key) => {\n        if (MOVEMENT_KEYS.LEFT.includes(key)) {\n            return { ...state, movement: MOVEMENT.LEFT }\n        } else if (MOVEMENT_KEYS.RIGHT.includes(key)) {\n            return {...state, movement: MOVEMENT.RIGHT }\n        }\n        return state\n    },\n    //On key up, check if a player wants to pause/resume the game and make appropriate operations with time.\n    [ACTION.KEY_UP]: (state, key) => {\n        const newState = { ...state, movement: undefined }\n        if (key === STOP_KEY) {\n          if (state.stopTime) {\n            return { ...newState, stopTime: undefined, time: state.time + Date.now() - state.stopTime}\n          } else {\n            return { ...newState, stopTime: Date.now() }\n          }\n        }\n        return newState\n      },\n        \n        //If game is on pause return to old state. Otherwise calculate how much time left from the last update and call a function from previous part\n        [ACTION.TICK]: state => {\n            if (state.stopTime) return state\n        \n            const time = Date.now()\n            const newGame = getNewGameState(state.game, state.movement, time - state.time)\n            const newState = { ...state, time }\n            if (newGame.lives < 1) {\n              return { ...newState, game: getGameStateFromLevel(LEVELS[state.level]) }\n            } else if (newGame.blocks.length < 1) {\n              const level = state.level === LEVELS.length ? state.level : state.level + 1\n              localStorage.setItem('level', level)\n              const game = getGameStateFromLevel(LEVELS[state.level])\n              return {\n                ...newState,\n                level,\n                game,\n                ...getProjectors(state.containerSize, game.size)\n              }\n            }\n            return { ...newState, game: newGame }\n          }\n        }\n    \n\n//Taking Handler for a received action type. If implemented the handler for this action then return a result of the call to the handler.\nconst reducer = (state, {\n    type,\n    payload\n}) => {\n    const handler = HANDLER[type]\n    if (!handler) return state\n    return handler(state, payload)\n}\n\n//Helper function to simplify the dispatch call.\nexport default (containerSize) => {\n    const [state, dispatch] = useReducer(reducer, containerSize, getInitialState)\n    const actionDispatch = (type, payload) => dispatch({ type, payload })\n    const {\n        projectDistance,\n        projectVector,\n        level,\n        game: {\n            blocks,\n            paddle,\n            ball,\n            size: {\n                width,\n                height\n            },\n            lives\n        }\n    } = state\n\n    //Utilizing useEffect hook to update projectors every time the size of the container changes. This hook makes the game look good regardless of the screen size.\n    useEffect(() => actionDispatch(ACTION.CONTAINER_SIZE_CHANGE, containerSize), [containerSize])\n \n    //On component mount, subscribe on keys presses and spin up the game timer. To remove all these handlers on unmount, returning a function that will do unregistering.\n    useEffect(() => {\n      const onKeyDown = ({ which }) => actionDispatch(ACTION.KEY_DOWN, which)\n      const onKeyUp = ({ which }) => actionDispatch(ACTION.KEY_UP, which)\n      const tick = () => actionDispatch(ACTION.TICK)\n  \n      const timerId = setInterval(tick, UPDATE_EVERY)\n      const unregisterKeydown = registerListener('keydown', onKeyDown)\n      const unregisterKeyup = registerListener('keyup', onKeyUp)\n      return () => {\n        clearInterval(timerId)\n        unregisterKeydown()\n        unregisterKeyup()\n      }\n    }, [])\n\n\n    //Taking properties needed from state and using projectors to render all SVG elements\n    const viewWidth = projectDistance(width)\n    const unit = projectDistance(ball.radius)\n    return (\n        <svg width={viewWidth} height={projectDistance(height)} className='scene'>\n          <Level unit={unit} level={level + 1} />\n          <Lives\n            lives={lives}\n            containerWidth={viewWidth}\n            unit={unit}\n          />\n          {blocks.map(({ density, position, width, height }) => (\n            <Block\n              density={density}\n              key={`${position.x}-${position.y}`}\n              width={projectDistance(width)}\n              height={projectDistance(height)}\n              {...projectVector(position)}\n            />)\n          )}\n          <Paddle width={projectDistance(paddle.width)} height={projectDistance(paddle.height)} {...projectVector(paddle.position)} />\n          <Ball {...projectVector(ball.center)} radius={unit} />\n        </svg> \n    )\n}","import Page from './components/page'\n\nexport default Page\n","import React, { useRef, useEffect, useState } from 'react'\n\nimport Scene from './scene'\nimport { registerListener } from '../utils'\n\nexport default () => {\n  const sceneContainer = useRef()\n  const [size, setSize] = useState()\n\n  useEffect(() => {\n    const onResize = () => {\n      const { width, height } = sceneContainer.current.getBoundingClientRect()\n      setSize({ width, height })\n    }\n    const unregisterResizeListener = registerListener('resize', onResize)\n    onResize()\n    return unregisterResizeListener\n  }, [])\n\n  return (\n    <div className='page'>\n      <div className='scene-container' ref={sceneContainer}>\n        {size && <Scene width={size.width} height={size.height} />}\n      </div>\n    </div>\n  )\n}\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}